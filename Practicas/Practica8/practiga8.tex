
\documentclass{article}

\usepackage{a4wide}
\usepackage[utf8]{inputenc}
\usepackage{enumerate}
\usepackage{xspace}
\usepackage{longtable}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{calc}
\usepackage{lmodern}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{mathdots}
\usepackage{mathtools}
\usepackage{multicol}
\usepackage{enumitem}
\usepackage{tasks}
\usepackage{pdfpages}
\usepackage{listings}
\lstset{
	language=C++,
	numbers=left,
	tabsize=3,
	basicstyle=\ttfamily,
}

\usepackage{bera}
\lstset{basicstyle=\ttfamily,}


\input{../macros/Algo1Macros}

\begin{document}

\includepdf[pages=-]{practica8.pdf}

\begin{center}
\section*{RESOLUCIONES.}
\end{center}
\paragraph{Ejercicio 1}.
\lstinputlisting{src/ej1.cpp}.
\paragraph{Ejercicio 2}.
\lstinputlisting{src/ej2.cpp}.
\paragraph{Ejercicio 3}.
\begin{enumerate}[label=\alph*)]
\item  Las generalizaciones son la muerte, más eficiente en relación a qué?.
 Si suponemos que los vectores de entrada rondan alrededor del tamaño donde se realizo la comparación
  entonces sin lugar a dudas A es más eficiente, sin embargo no tengo ese dato, y como no se como se comportan los algoritmos
   en el limite del tamaño del vector tendiendo a infinito no puedo asegurar que uno sea mejor que otro, por lo tanto esa afirmación es falsa.
\item Esta afirmación es falsa, ambos algoritmos difieren en catidad de operaciones por una constante, por lo tanto su tiempo de ejecución no tiene por que ser el mismo, lo que si se puede afirmar es que a medida que n se haga cada vez más grande sus tiempos de ejecución se van a empezar a asemejar.
\item Por intuición y porque como ya dije antes, las generalizaciones son la muerte, se que no puedo decir que simplemente para todo programa con complejidad $O(log(n))$, si $n>100$ entonces se va a ejecutar más rapido que otro de complejidad $O(n)$, que clase de numero divino es el 100 como para poder afirmar semejante guasada. Un contraejemplo pavo seria el siguiente:
\begin{itemize}
\item $t(n)= n \rightarrow O(n)$
\item $t(n)= 101+log(n) \rightarrow O(log(n))$
\end{itemize}
\item Es intuitivo, pero la demostración formal se me escapa de las manos en este instante.
\item Falso, contraejemplo: el ciclo de afuera no tiene porque necesariamente depender de $n$.
\end{enumerate}
\paragraph{Ejercicio 4.}
\begin{enumerate}[label=\alph*)]
\item Devuelve la posición del elemento que tenga mas elementos repetidos a su izquierda.
\item .\\ \lstinputlisting{src/ej4.cpp}.
\item no se me ocurre.
\end{enumerate}
\paragraph{Ejercicio 5}.
\lstinputlisting{src/ej5.cpp}.
\end{document}