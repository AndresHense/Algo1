
\documentclass{article}

\usepackage{a4wide}
\usepackage[utf8]{inputenc}
\usepackage{enumerate}
\usepackage{xspace}
\usepackage{longtable}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{calc}
\usepackage{lmodern}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{mathdots}
\usepackage{mathtools}
\usepackage{multicol}
\usepackage{enumitem}
\usepackage{tasks}
\usepackage{pdfpages}
\usepackage{listings}
\lstset{
	language=C++,
	numbers=left,
	tabsize=3,
	basicstyle=\ttfamily,
}

\usepackage{bera}
\lstset{basicstyle=\ttfamily,}


\input{../macros/Algo1Macros}

\begin{document}

\includepdf[pages=-]{practica8.pdf}

\begin{center}
\section*{RESOLUCIONES.}
\end{center}
\paragraph{Ejercicio 1}.
\lstinputlisting{src/ej1.cpp}.
\paragraph{Ejercicio 2}.
\lstinputlisting{src/ej2.cpp}.
\paragraph{Ejercicio 3}.
\begin{enumerate}[label=\alph*)]
\item  Las generalizaciones son la muerte, más eficiente en relación a qué?.
 Si suponemos que los vectores de entrada rondan alrededor del tamaño donde se realizo la comparación
  entonces sin lugar a dudas A es más eficiente, sin embargo no tengo ese dato, y como no se como se comportan los algoritmos
   en el limite del tamaño del vector tendiendo a infinito no puedo asegurar que uno sea mejor que otro, por lo tanto esa afirmación es falsa.
\item Esta afirmación es falsa, ambos algoritmos difieren en catidad de operaciones por una constante, por lo tanto su tiempo de ejecución no tiene por que ser el mismo, lo que si se puede afirmar es que a medida que n se haga cada vez más grande sus tiempos de ejecución se van a empezar a asemejar.
\item Por intuición y porque como ya dije antes, las generalizaciones son la muerte, se que no puedo decir que simplemente para todo programa con complejidad $O(log(n))$, si $n>100$ entonces se va a ejecutar más rapido que otro de complejidad $O(n)$, que clase de numero divino es el 100 como para poder afirmar semejante guasada. Un contraejemplo pavo seria el siguiente:
\begin{itemize}
\item $t(n)= n \rightarrow O(n)$
\item $t(n)= 101+log(n) \rightarrow O(log(n))$
\end{itemize}
\item Es intuitivo, pero vamos a demostrarlo, para eso hay que demostrar que $log(n)\leq n$, vamos a hacerlo usando inducción. Reescribamos la expresión para que quede mas manejable.
\begin{align*}
log(n) &\leq n\\
e^{log(n)} &\leq e^n\\
n &\leq e^n
\end{align*}
Mi hipotesis inductiva es : $$\textbf{HI:\ }n \leq e^n$$ \\
\begin{align*}
\textrm{quiero ver que}\qquad n+1 &\leq e^{n+1}\\
\textrm{por HI}\qquad n &\leq e^n\\
\leftrightarrow n +1 &\leq e^n +1\\
\textrm{por transitividad}\qquad e^n +1 &\leq e^{n+1}\\
\frac{e^n +1}{e^n} &\leq \frac{e^{n+1}}{e^n}\\
\textrm{nueva HI}\qquad \frac{1}{e^n} &\leq e-1\\
\textrm{qvq}\qquad \frac{1}{e^{n+1}} &\leq e-1\\
\textrm{por HI}\qquad  \frac{1}{e^n} &\leq e-1\\
\leftrightarrow \frac{1}{e^n}\frac{1}{e} &\leq \frac{e-1}{e} \\
\leftrightarrow \frac{1}{e^{n+1}} &\leq 1-\frac{1}{e} \\
\textrm{por transitividad}\qquad 1-\frac{1}{e}&\leq e-1\\
\leftrightarrow 2 &\leq e+\frac{1}{e} 
\end{align*}$\square$

\item Falso, contraejemplo: el ciclo de afuera no tiene porque necesariamente depender de $n$.
\end{enumerate}
\paragraph{Ejercicio 4.}
\begin{enumerate}[label=\alph*)]
\item Devuelve la posición del elemento que tenga mas elementos repetidos a su izquierda.
\item .\\ \lstinputlisting{src/ej4.cpp}.
\item no se me ocurre.
\end{enumerate}
\paragraph{Ejercicio 5}.
\lstinputlisting{src/ej5.cpp}.
\paragraph{Ejercicio 6.}
\begin{enumerate}[label=\alph*)]
\item Basicamente lo que hace es devolver falso si todos los elementos del vector
	son menores o iguales a cero. EJ $f([-1,0,-3,-5,0])=false$
\item .\\ \lstinputlisting{src/Ej6.cpp}.
\item \begin{itemize}
			\item Mejor caso: $f([-1,0,-3,-5,0])$
			\item Peor caso: $f([1,2,3,4,5,6,7])$
		\end{itemize}	
\end{enumerate}
\paragraph{Ejercicio 7}.
\begin{enumerate}[label=\alph*)]
\item .\\\lstinputlisting{src/ej7.cpp}.
\item No se puede creo.
\item mmm, tiene pinta de telescopica(creo q no se llama asi, bueno esa propiedad de las potencias q dieron en algebra 1, que se probaba con induccion).
\end{enumerate}

\end{document}
